#pragma kernel CalcGridDensities // 0

#include "RendererResources.hlsl"

// Marching squares settings
const int3 NumCellsMS;
const float CellSizeMS;

// Render world settings
const int4 NumChunks;
const float CellSize;
const int NumObjects;
const float3 ChunkGridOffset;

RWStructuredBuffer<int2> SpatialLookup; // [NumObjects](objectIndex, ChunkKey)
RWStructuredBuffer<int> StartIndices;

RWStructuredBuffer<Sphere> Spheres;

RWTexture3D<float> GridDensities;

bool ValidChunk(int3 chunk)
{
    return chunk.x >= 0 && chunk.x < (int)NumChunks.x &&
           chunk.y >= 0 && chunk.y < (int)NumChunks.y &&
           chunk.z >= 0 && chunk.z < (int)NumChunks.z;
}

int GetChunkKey(int3 chunk)
{
    return chunk.x + chunk.y * NumChunks.x + chunk.z * NumChunks.w;
}

NearInfo GetNear(float3 pos)
{
    uint3 chunk = uint3(pos / CellSize);
    int chunkKey = GetChunkKey(chunk);
    int startIndex = StartIndices[chunkKey];

    NearInfo nearInfo;
    nearInfo.materialKey = -1;
    float nearDstSqr = FLT_MAX;
    int index = startIndex;
    while (index != -1 && chunkKey == SpatialLookup[index].y)
    {
        int sphereIndex = SpatialLookup[index].x;
        Sphere sphere = Spheres[sphereIndex];

        float3 dst = pos - sphere.pos;
        float dstSqr = dot2(dst);
        if (dstSqr < nearDstSqr)
        {
            nearDstSqr = dstSqr;
            nearInfo.materialKey = sphere.materialKey;
        }

        // -- Increment index each iteration - Chunk particle search algorithm --

        index += 1;
    }

    nearInfo.dst = sqrt(nearDstSqr);

    return nearInfo;
}

NearInfo GetNearExpanded(float3 pos, int radius)
{
    uint3 chunk = uint3(pos / CellSize);

    NearInfo nearInfo;
    nearInfo.materialKey = -1;
    float nearDstSqr = FLT_MAX;
    for (int x = -radius; x <= radius; x++)
    {
        for (int y = -radius; y <= radius; y++)
        {
            for (int z = -radius; z <= radius; z++)
            {
                int3 curChunk = chunk + int3(x, y, z);

                if (!ValidChunk(curChunk)) {continue;}

                int chunkKey = GetChunkKey(curChunk);
                int startIndex = StartIndices[chunkKey];

                int index = startIndex;
                while (index != -1 && chunkKey == SpatialLookup[index].y)
                {
                    int sphereIndex = SpatialLookup[index].x;
                    Sphere sphere = Spheres[sphereIndex];

                    float3 dst = pos - sphere.pos;
                    float dstSqr = dot2(dst);
                    if (dstSqr < nearDstSqr)
                    {
                        nearDstSqr = dstSqr;
                        nearInfo.materialKey = sphere.materialKey;
                    }

                    // -- Increment index each iteration - Chunk particle search algorithm --

                    index += 1;
                }
            }
        }
    }

    nearInfo.dst = sqrt(nearDstSqr);

    return nearInfo;
}

// Similar to a density map, but cheaper
[numthreads(TN_MS,TN_MS,TN_MS)]
void CalcGridDensities (uint3 msCell : SV_DispatchThreadID)
{
    float3 pos = (msCell + 0.5) * CellSizeMS + ChunkGridOffset;

    NearInfo nearInfo = GetNear(pos);

    GridDensities[msCell] = max(1 - nearInfo.dst*0.02, 0.01) + nearInfo.materialKey*.5;
}