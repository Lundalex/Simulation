#pragma kernel CalcGridDensities // 0
#pragma kernel FindSurface // 1
#pragma kernel GenerateFluidMesh // 2
#pragma kernel DeleteFluidMesh // 3
#pragma kernel TransferFluidMesh // 4

#include "RendererResources.hlsl"
#include "LookupTableMS.hlsl"

// Marching squares settings
const float CellSizeMS;

// Render world settings
const uint4 NumChunks;
const float CellSize;
const float3 ChunkGridOffset;

const uint DynamicNumTris;
const uint ReservedNumTris;

RWStructuredBuffer<int2> SpatialLookup; // [NumObjects](objectIndex, ChunkKey)
RWStructuredBuffer<int> StartIndices;

RWStructuredBuffer<Sphere> Spheres;

RWTexture3D<float> GridDensities;
RWTexture3D<float> SurfaceCells;

AppendStructuredBuffer<int3> SurfaceCellsAPPEND;
ConsumeStructuredBuffer<int3> SurfaceCellsCONSUME;

AppendStructuredBuffer<Tri2> FluidTriMeshAPPEND;
ConsumeStructuredBuffer<Tri2> FluidTriMeshCONSUME;

RWStructuredBuffer<Tri> Tris;

bool ValidChunk(int3 chunk)
{
    return chunk.x >= 0 && chunk.x < (int)NumChunks.x &&
           chunk.y >= 0 && chunk.y < (int)NumChunks.y &&
           chunk.z >= 0 && chunk.z < (int)NumChunks.z;
}

int GetChunkKey(int3 chunk)
{
    return chunk.x + chunk.y * NumChunks.x + chunk.z * NumChunks.w;
}

NearInfo GetNear(float3 pos)
{
    uint3 chunk = uint3(pos / CellSize);
    int chunkKey = GetChunkKey(chunk);
    int startIndex = StartIndices[chunkKey];

    NearInfo nearInfo;
    nearInfo.materialKey = -1;
    float nearDstSqr = FLT_MAX;
    int index = startIndex;
    while (index != -1 && chunkKey == SpatialLookup[index].y)
    {
        int sphereIndex = SpatialLookup[index].x;
        Sphere sphere = Spheres[sphereIndex];

        float3 dst = pos - sphere.pos;
        float dstSqr = dot2(dst);
        if (dstSqr < nearDstSqr)
        {
            nearDstSqr = dstSqr;
            nearInfo.materialKey = sphere.materialKey;
        }

        // -- Increment index each iteration - Chunk particle search algorithm --

        index += 1;
    }

    nearInfo.dst = sqrt(nearDstSqr);

    return nearInfo;
}

NearInfo GetNearExpanded(float3 pos, int radius)
{
    uint3 chunk = uint3(pos / CellSize);

    NearInfo nearInfo;
    nearInfo.materialKey = -1;
    float nearDstSqr = FLT_MAX;
    for (int x = -radius; x <= radius; x++)
    {
        for (int y = -radius; y <= radius; y++)
        {
            for (int z = -radius; z <= radius; z++)
            {
                int3 curChunk = chunk + int3(x, y, z);

                if (!ValidChunk(curChunk)) {continue;}

                int chunkKey = GetChunkKey(curChunk);
                int startIndex = StartIndices[chunkKey];

                int index = startIndex;
                while (index != -1 && chunkKey == SpatialLookup[index].y)
                {
                    int sphereIndex = SpatialLookup[index].x;
                    Sphere sphere = Spheres[sphereIndex];

                    float3 dst = pos - sphere.pos;
                    float dstSqr = dot2(dst);
                    if (dstSqr < nearDstSqr)
                    {
                        nearDstSqr = dstSqr;
                        nearInfo.materialKey = sphere.materialKey;
                    }

                    // -- Increment index each iteration - Chunk particle search algorithm --

                    index += 1;
                }
            }
        }
    }

    nearInfo.dst = sqrt(nearDstSqr);

    return nearInfo;
}

// Similar to a density map, but cheaper
[numthreads(TN_MS,TN_MS,TN_MS)]
void CalcGridDensities (uint3 msCell : SV_DispatchThreadID)
{
    float3 pos = (msCell + 0.5) * CellSizeMS + ChunkGridOffset;

    NearInfo nearInfo = GetNear(pos);

    GridDensities[msCell] = max(1 - nearInfo.dst*0.02, 0.0) + nearInfo.materialKey*.5;
}

[numthreads(TN_MS,TN_MS,TN_MS)]
void FindSurface (uint3 baseCell : SV_DispatchThreadID)
{
    float densities[8];
    bool c0_0_0 = GridDensities[baseCell] == 0.0;
    bool c1_0_0 = GridDensities[baseCell + uint3(1,0,0)] == 0.0;
    bool c0_1_0 = GridDensities[baseCell + uint3(1,0,1)] == 0.0;
    bool c1_1_0 = GridDensities[baseCell + uint3(0,0,1)] == 0.0;
    bool c0_0_1 = GridDensities[baseCell + uint3(0,1,0)] == 0.0;
    bool c1_0_1 = GridDensities[baseCell + uint3(1,1,0)] == 0.0;
    bool c0_1_1 = GridDensities[baseCell + uint3(1,1,1)] == 0.0;
    bool c1_1_1 = GridDensities[baseCell + uint3(0,1,1)] == 0.0;

    if ((c0_0_0 || c1_0_0 || c0_1_0 || c1_1_0 || c0_0_1 || c1_0_1 || c0_1_1 || c1_1_1)
        && !(c0_0_0 && c1_0_0 && c0_1_0 && c1_1_0 && c0_0_1 && c1_0_1 && c0_1_1 && c1_1_1))
    {
        SurfaceCells[baseCell] = 1.0;
        SurfaceCellsAPPEND.Append(int3(baseCell));
    }
    else
    {
        SurfaceCells[baseCell] = 0.5;
    }
}

float3 interpolateVerts(float d1, float d2, float3 v1, float3 v2, float threshold)
{
    float t = saturate((threshold - d1) / (d2 - d1));
    
    return lerp(v1, v2, t);
}

[numthreads(TN_MS2,1,1)]
void GenerateFluidMesh (uint3 id : SV_DispatchThreadID)
{
    // uint3 baseCell = id.xyz;
    uint3 baseCell = uint3(SurfaceCellsCONSUME.Consume());

    uint3 localPositions[8] = {
        baseCell,
        baseCell + uint3(1,0,0),
        baseCell + uint3(1,0,1),
        baseCell + uint3(0,0,1),
        baseCell + uint3(0,1,0),
        baseCell + uint3(1,1,0),
        baseCell + uint3(1,1,1),
        baseCell + uint3(0,1,1)
    };

    float densities[8] = {
        GridDensities[localPositions[0]],
        GridDensities[localPositions[1]],
        GridDensities[localPositions[2]],
        GridDensities[localPositions[3]],
        GridDensities[localPositions[4]],
        GridDensities[localPositions[5]],
        GridDensities[localPositions[6]],
        GridDensities[localPositions[7]]
    };

    // Calculate unique index for each cube configuration.
    // There are 256 possible values
    // A value of 0 means cube is entirely inside surface; 255 entirely outside.
    // The value is used to look up the edge table, which indicates which edges of the cube are cut by the isosurface.
    float threshold = 0.5;
    int cubeIndex = 0;
    if (densities[0] > threshold) cubeIndex |= 1;
    if (densities[1] > threshold) cubeIndex |= 2;
    if (densities[2] > threshold) cubeIndex |= 4;
    if (densities[3] > threshold) cubeIndex |= 8;
    if (densities[4] > threshold) cubeIndex |= 16;
    if (densities[5] > threshold) cubeIndex |= 32;
    if (densities[6] > threshold) cubeIndex |= 64;
    if (densities[7] > threshold) cubeIndex |= 128;

    // Create triangles for current cube configuration
    for (int i = 0; triangulation[cubeIndex][i] != -1; i +=3) {
        // Get indices of corner points A and B for each of the three edges
        // of the cube that need to be joined to form the triangle.
        int a0 = cornerIndexAFromEdge[triangulation[cubeIndex][i]];
        int b0 = cornerIndexBFromEdge[triangulation[cubeIndex][i]];

        int a1 = cornerIndexAFromEdge[triangulation[cubeIndex][i+1]];
        int b1 = cornerIndexBFromEdge[triangulation[cubeIndex][i+1]];

        int a2 = cornerIndexAFromEdge[triangulation[cubeIndex][i+2]];
        int b2 = cornerIndexBFromEdge[triangulation[cubeIndex][i+2]];

        Tri2 tri;
        tri.vA = interpolateVerts(densities[a0], densities[b0], localPositions[a0], localPositions[b0], threshold);
        tri.vB = interpolateVerts(densities[a1], densities[b1], localPositions[a1], localPositions[b1], threshold);
        tri.vC = interpolateVerts(densities[a2], densities[b2], localPositions[a2], localPositions[b2], threshold);

        // Transform to render world space
        tri.vA = tri.vA * CellSizeMS + ChunkGridOffset;
        tri.vB = tri.vB * CellSizeMS + ChunkGridOffset;
        tri.vC = tri.vC * CellSizeMS + ChunkGridOffset;

        FluidTriMeshAPPEND.Append(tri);
    }
}

[numthreads(TN_MS2,1,1)]
void DeleteFluidMesh (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= DynamicNumTris) return;
    uint i = id.x + ReservedNumTris;

    Tri tri;
    tri.vA = 0;
    tri.vB = 0;
    tri.vC = 0;
    tri.normal = 0;
    tri.materialKey = 0;
    tri.parentKey = 0;

    Tris[i] = tri;
}

[numthreads(TN_MS2,1,1)]
void TransferFluidMesh (uint3 id : SV_DispatchThreadID)
{
    Tri2 tri2 = FluidTriMeshCONSUME.Consume();
    if (all(tri2.vA) == 0 && all(tri2.vB) == 0 && all(tri2.vC) == 0) return;

    Tri tri;
    tri.vA = tri2.vA;
    tri.vB = tri2.vB;
    tri.vC = tri2.vC;
    tri.normal = 0;
    tri.materialKey = 0;
    tri.parentKey = 0;

    Tris[id.x + ReservedNumTris] = tri;
}