#pragma kernel ApplyLocalAngularRotation // 0
#pragma kernel PopulateTraversedChunks // 1
#pragma kernel ResolveLineCollisions // 2
#pragma kernel RBForces // 3

#include "SimulationResources.hlsl"
#include "CompositionResources.hlsl"

// Constants
const int2 ChunksNum;
const int Width;
const int Height;
const int ParticlesNum;
const int RBodiesNum;
const int RBVectorNum;
const int MaxInfluenceRadius;
const int MaxChunkSearchSafety;
const float Damping;
// const float Viscosity;
const float Gravity;
const float RbElasticity;
const float BorderPadding;

// Per-timestep-set constants
const float DeltaTime;
const int DoCalcStickyRequests;

// Particles - Buffers
RWStructuredBuffer<int2> SpatialLookup; // [ParticlesNum](particleIndex, ChunkKey)
RWStructuredBuffer<int> StartIndices;

RWStructuredBuffer<PTypeStruct> PTypes;
RWStructuredBuffer<PDataStruct> PData;

RWStructuredBuffer<RBDataStruct> RBData;
RWStructuredBuffer<RBVectorStruct> RBVector;

AppendStructuredBuffer<int3> TraversedChunksAPPEND;
ConsumeStructuredBuffer<int3> TraversedChunksCONSUME;

AppendStructuredBuffer<StickynessRequestStruct> StickynessReqsAPPEND;

bool ValidChunk(int ChunkX, int ChunkY)
{
    return ChunkX >= 0 && ChunkX < ChunksNum.x && ChunkY >= 0 && ChunkY < ChunksNum.y;
}

bool RBBoundraryCheck(float2 Point, float extraPadding)
{
    return Point.x > BorderPadding + extraPadding && Point.x < Width - BorderPadding - extraPadding && Point.y > BorderPadding + extraPadding && Point.y < Height - BorderPadding - extraPadding;
}

void RBBoundraryCollision(float2 pos, int RBIndex, float extraPadding, float Damping) {
    float totPadding = BorderPadding + extraPadding;
    RBDataStruct rb = RBData[RBIndex];

    // x
    if (pos.x > Width - totPadding) {
        RBData[RBIndex].NextVel.x = -abs(rb.NextVel.x) * Damping;
        RBData[RBIndex].NextPos.x -= pos.x - (Width - totPadding);
    } else if (pos.x < totPadding) {
        RBData[RBIndex].NextVel.x = abs(rb.NextVel.x) * Damping;
        RBData[RBIndex].NextPos.x += totPadding - pos.x;
    }
    
    // y
    if (pos.y > Height - totPadding) {
        RBData[RBIndex].NextVel.y = -abs(rb.NextVel.y) * Damping;
        RBData[RBIndex].NextPos.y -= pos.y - (Height - totPadding);
    } else if (pos.y < totPadding) {
        RBData[RBIndex].NextVel.y = abs(rb.NextVel.y) * Damping;
        RBData[RBIndex].NextPos.y += totPadding - pos.y;
    }
}

void TraverseLineSegment(float startX, float startY, float endX, float endY, int LineIndex, int Margin) {
    bool steep = abs(endY - startY) > abs(endX - startX);

    if (steep) {
        // Swap X and Y
        float temp = startX;
        startX = startY;
        startY = temp;
        temp = endX;
        endX = endY;
        endY = temp;
    }

    if (startX > endX) {
        // Swap start and end points
        float tempX = startX;
        float tempY = startY;
        startX = endX;
        startY = endY;
        endX = tempX;
        endY = tempY;
    }

    float dx = endX - startX;
    float dy = abs(endY - startY);
    float error = dx / 2.0f;
    float ystep = (startY < endY) ? 1 : -1;
    float y = startY;

    for (float x = startX; x <= endX; x++) {
        for (int mx = -Margin; mx <= Margin; mx++) {
            for (int my = -Margin; my <= Margin; my++) {
                int3 cell = steep ? int3(y + my, x + mx, LineIndex) : int3(x + mx, y + my, LineIndex);
                TraversedChunksAPPEND.Append(cell);
            }
        }

        error -= dy;
        if (error < 0) {
            y += ystep;
            error += dx;
        }
    }
}

bool CheckCollision(float2 nextFramePosDisplacement, float2 dstToLine) {
    float uLength = length(dstToLine);
    if (uLength == 0) {
        return false;
    }

    float dotProductVU = dot(nextFramePosDisplacement, dstToLine);
    if (dotProductVU < 0) {
        // Projection is in the opposite direction
        return false;
    }

    float projectionLength = abs(dotProductVU) / uLength;
    return projectionLength > uLength;
}

void AddRBPStickyness(float absDstToLineSqr, float2 dstToLine, int pIndex, int lineIndex, RBDataStruct RBData_i, int randSeed)
{
    // StickynessRange should stay smaller than ~chunksearchDst to avoid visual artifacts
    if (absDstToLineSqr > RBData_i.StickynessRangeSqr) { return; }

    StickynessRequestStruct stickynessRequest;
    stickynessRequest.pIndex = pIndex;
    stickynessRequest.StickyLineIndex = lineIndex;
    stickynessRequest.StickyLineDst = dstToLine;
    stickynessRequest.absDstToLineSqr = absDstToLineSqr + 0.01 * rand(randSeed);
    stickynessRequest.RBStickyness = RBData_i.Stickyness;
    stickynessRequest.RBStickynessRange = RBData_i.StickynessRange;

    StickynessReqsAPPEND.Append(stickynessRequest);
}

float3 ResolveCollision(PDataStruct PData_i, PTypeStruct PType_i, RBDataStruct parentRBData, float2 NormLineVector, int pIndex, float2 NextPosChange, float2 NextVel, float NextAngImpulse)
{
    // is wallDir pointing IN or OUT, and does it matter? Is is probably the result of a 90 degree turn a (clockwise or anticlockwise) direction
    float2 perpNormLineVector = float2(NormLineVector.y, -NormLineVector.x);

    // When adding circular motion, this will have to be updated
    float2 RBVel = NextVel;
    float2 diffVel = PData_i.Velocity - RBVel;

    // float2 normDst = normalize(dst); = perpNormLineVector
    // float2 wallDir = float2(normDst.y, -normDst.x);

    // v = (a,b)
    // u = (c,d) (u is normalized)
    // => v':
    // v'_x = (2c^2-1)*a + 2cdb
    // v'_y = 2cda + (2d^2-1)b
    // Mirror vel_diff through normDst

    // reflect() CAN BE USED FOR REFLECTION CALCULATION
    float a = diffVel.x;
    float b = diffVel.y;
    float c = perpNormLineVector.x;
    float d = perpNormLineVector.y;

    float mirrorDiffVelX = (2*c*c-1)*a + 2*c*d*b;
    float mirrorDiffVelY = 2*c*d*a + (2*d*d-1)*b;
    float2 mirrorDiffVel = float2(-mirrorDiffVelX, -mirrorDiffVelY);

    float2 collisionImpulse = mirrorDiffVel - diffVel;

    float2 exchangedMomentum = collisionImpulse * RbElasticity;

    // Not currently in use. Also, this is not equal to the energy loss by the collision since temperature_energy is not proportional to vel_energy;
    // float absOverflowMomentum = length(collisionImpulse * (1 - RbElasticity));

    // v = (a,b)
    // u = (c,d) (u is normalized)
    // => v_projected:
    // v_projected_x = (ac+bd)*c
    // v_projected_y = (ac+bd)*d
    // Momentum and circular impulses:

    // Vector2 centerImpulse = exchangedMomentum [proj to] normDst
    // Vector2 rotation_impulse = exchangedMomentum [proj to] wallDir
    // float2 centerImpulse = exchangedMomentum; // not usable - RB Impulse!!!!!
    // RBVelocities[i] -= centerImpulse / (2 * RBProperties[i].y); // not usable - RB Impulse!!!!!

    // float2 relCollisionPos = RBProperties[i].x * normDst;
    // float2 newParticlePos = RBPositions[i] + relCollisionPos;
    // PData[particleIndex].Position = newParticlePos;

    // PData[pIndex].Velocity += exchangedMomentum * 0.5;
    // PData[pIndex].Velocity = float2(0, 0);
    PData[pIndex].Velocity += exchangedMomentum;
    // Slightly offset the particle from the RB surface to minimize the risk of particles glitching through as very low velocities
    PData[pIndex].Position = rotate2d(((PData[pIndex].Position + NextPosChange + 0.05*perpNormLineVector) - parentRBData.Position), NextAngImpulse) + parentRBData.Position + 0.05*perpNormLineVector;

    // RB Impulse calculations
    float2 RBtotImpulse = -exchangedMomentum;
    // Collision position can be approximated to PData_i.Position
    float2 collPos = PData_i.Position;
    float2 normRelCollPos = normalize(collPos - parentRBData.Position);
    float2 perpnormRelCollPos = float2(normRelCollPos.y, -normRelCollPos.x);

    float2 centerImpulse = dot(normRelCollPos, RBtotImpulse) * normRelCollPos;

    float rotaryImpulse = dot(-perpnormRelCollPos, RBtotImpulse);

    return float3(centerImpulse.x, centerImpulse.y, rotaryImpulse);
}

[numthreads(TN_RB,1,1)]
void ApplyLocalAngularRotation (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if (i >= RBVectorNum) { return; }

    RBVectorStruct lineVector = RBVector[i];

    float rotationAngle = RBData[lineVector.ParentRBIndex].AngularImpulse;
    if (rotationAngle == 0) {return;}
    RBVector[i].Position = rotate2d(RBVector[i].Position, rotationAngle);
}

[numthreads(TN_RB,1,1)]
void PopulateTraversedChunks (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if (i >= RBVectorNum + 1) { return; }

    RBVectorStruct lineVectorA = RBVector[i];
    RBVectorStruct lineVectorB = RBVector[i+1];

    if (lineVectorA.ParentRBIndex != lineVectorB.ParentRBIndex) { return; }

    float2 parentPos = RBData[lineVectorA.ParentRBIndex].Position; // A and B have the same parent
    float2 startWorldPos = lineVectorA.Position + parentPos;
    float2 endWorldPos = lineVectorB.Position + parentPos;
    float2 startChunkPos = startWorldPos / (float)MaxInfluenceRadius;
    float2 endChunkPos = endWorldPos / (float)MaxInfluenceRadius;
    if (!RBBoundraryCheck(startWorldPos, 0))
    {
        RBVector[i].WallCollision = 1;
        int ogv;
        InterlockedAdd(RBData[lineVectorA.ParentRBIndex].WallCollision, 1, ogv);
    }
    TraverseLineSegment(startChunkPos.x, startChunkPos.y, endChunkPos.x, endChunkPos.y, i, MaxChunkSearchSafety);
}

[numthreads(TN_RB, 1, 1)]
void ResolveLineCollisions(uint3 id : SV_DispatchThreadID)
{
    int randSeed = id.x;
    int3 curChunk = TraversedChunksCONSUME.Consume();
    int curChunkX = curChunk.x;
    int curChunkY = curChunk.y;
    int lineIndex = curChunk.z;

    RBVectorStruct lineVectorA = RBVector[lineIndex];
    RBVectorStruct lineVectorB = RBVector[lineIndex+1];

    // if (!valid line || !valid chunk || !line vectors have the same parent) { return; }
    if ((curChunkX == 0 && curChunkY == 0 && lineIndex == 0) || !ValidChunk(curChunkX, curChunkY) || lineVectorA.ParentRBIndex != lineVectorB.ParentRBIndex) { return; }

    RBDataStruct parentRBData = RBData[lineVectorA.ParentRBIndex]; // A and B have the same parent
    
    float2 NextPos = parentRBData.NextPos;
    float2 NextPosChange = NextPos - parentRBData.Position;
    float2 NextVel = parentRBData.NextVel;
    float NextAngImpulse = parentRBData.NextAngImpulse;

    int ChunkKey = curChunkY * ChunksNum.x + curChunkX;
    int startIndex = StartIndices[ChunkKey];

    // centerImpulse, rotaryImpulse
    float3 totLineImpulse = float3(0.0, 0.0, 0.0);
    int Index = startIndex; 
    while (Index < ParticlesNum && ChunkKey == SpatialLookup[Index].y)
    {
        int pIndex = SpatialLookup[Index].x;

        PDataStruct PData_i = PData[pIndex];
        PTypeStruct PType_i = PTypes[Extract_PType(PData_i.LastChunkKey_PType_POrder)];

        float2 A = PData_i.Position;
        float2 B = rotate2d(((PData_i.Position + PData_i.Velocity * DeltaTime - NextPosChange) - parentRBData.Position), -NextAngImpulse) + parentRBData.Position;
        float2 C = lineVectorA.Position + parentRBData.Position;
        float2 D = lineVectorB.Position + parentRBData.Position;

        if (DoCalcStickyRequests)
        {
            float2 dstToLine = dstToLineSegment(C, D, A);
            float absDstToLineSqr = dot(dstToLine, dstToLine);
            AddRBPStickyness(absDstToLineSqr, dstToLine, pIndex, lineIndex, parentRBData, randSeed);
        }

        if (CheckLinesIntersect(A, B, C, D))
        {
            // Particle velocity is currently reflecting off of last-frame line position!
            float2 LineVectorNorm = normalize(lineVectorB.Position - lineVectorA.Position);
            totLineImpulse += ResolveCollision(PData_i, PType_i, parentRBData, LineVectorNorm, pIndex, NextPosChange, NextVel, NextAngImpulse);
        }

        // Increment Index each iteration - Chunk particle search algorithm
        Index += 1;
    }

    // Add totLineImpulse to current line's parent RB
    RBVector[lineIndex].ParentImpulse = totLineImpulse;
}

float3 RBImpulse(RBDataStruct RBData_i)
{
    int startIndex = RBData_i.LineIndices.x;
    int endIndex = RBData_i.LineIndices.y;
    float3 totRBImpulse = float3(0.0, 0.0, 0.0);
    for (int lineIndex = startIndex; lineIndex < endIndex; lineIndex++)
    {
        totRBImpulse += RBVector[lineIndex].ParentImpulse;
    }
    return totRBImpulse;
}

[numthreads(TN_RB, 1, 1)]
void RBForces(uint3 id : SV_DispatchThreadID)
{
    int i = id.x;

    RBDataStruct RBData_i = RBData[i];
    if (RBData_i.Stationary || i >= RBodiesNum) { return; }

    float3 totRBImpulse = RBImpulse(RBData_i);

    RBData[i].Velocity = RBData_i.NextVel;
    RBData[i].AngularImpulse = RBData_i.NextAngImpulse;
    RBData[i].Position = RBData_i.NextPos;

    RBData[i].NextPos += RBData[i].Velocity * DeltaTime;
    RBData[i].NextVel += float2(totRBImpulse.x, totRBImpulse.y) / RBData_i.Mass;
    RBData[i].NextVel.y -= Gravity * 0.15 * DeltaTime;

    int startIndex = RBData_i.LineIndices.x;
    int endIndex = RBData_i.LineIndices.y;
    if (RBData_i.WallCollision)
    {
        int WallCollisions = RBData_i.WallCollision;
        RBData[i].WallCollision = 0;
        for (int lineIndex = startIndex; lineIndex < endIndex; lineIndex++)
        {
            if (RBVector[lineIndex].WallCollision)
            {
                float2 collPoint = RBData[i].Position + RBVector[lineIndex].Position;
                RBBoundraryCollision(collPoint, i, 0, 0.3);

                WallCollisions--;
                if (WallCollisions == 0) { break; }
            }
        }
    }
}