#pragma kernel TransferParticlePositionData // 0

#include "Renderer/RendererDataTypes.hlsl"
#include "Simulation/SimulationDataTypes.hlsl"

const uint ParticlesNum;
const float Radius;
const int ChunksNumAll;
const int PTypesNum;
const float3 Rot;

RWStructuredBuffer<PData> PDataB;
RWStructuredBuffer<PType> PTypes;

RWStructuredBuffer<Sphere> Spheres;

int Extract_PType(int LastChunkKey_PType_POrder)
{
    return ((uint)LastChunkKey_PType_POrder % (ChunksNumAll * PTypesNum)) / ChunksNumAll;
}

float3 ApplyTransformTriVertices(float3 rot, float3 a)
{
    float cosX = cos(rot.x);
    float sinX = sin(rot.x);
    float cosY = cos(rot.y);
    float sinY = sin(rot.y);
    float cosZ = cos(rot.z);
    float sinZ = sin(rot.z);

    // Combine rotation matrices into a single matrix
    float3x3 rotationMatrix = float3x3(
        cosY * cosZ,                             cosY * sinZ,                           -sinY,
        sinX * sinY * cosZ - cosX * sinZ,   sinX * sinY * sinZ + cosX * cosZ,  sinX * cosY,
        cosX * sinY * cosZ + sinX * sinZ,   cosX * sinY * sinZ - sinX * cosZ,  cosX * cosY
    );

    // Apply the combined rotation matrix to each vertex
    return mul(rotationMatrix, a);
}

[numthreads(512,1,1)] // TEMP
void TransferParticlePositionData (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= ParticlesNum) { return; }

    PData pData = PDataB[i];
    // PType pType = PTypes[Extract_PType(pData.LastChunkKey_PType_POrder)];
    int pTypeIndex = Extract_PType(pData.LastChunkKey_PType_POrder);

    Sphere sphere;

    float3 pos = float3(pData.Position.x, pData.Position.y, pData.Position.z) * .1;
    sphere.pos = ApplyTransformTriVertices(Rot, pos - float3(7.5, 10, 2.5)) + float3(15, 10, 2.5);
    sphere.radius = Radius;
    sphere.materialKey = pTypeIndex == 1 || pTypeIndex == 2 ? 1 : 0;

    Spheres[i] = sphere;
}